---
title: "Oficina de R"
author: "Nathan Giachetta & Rafael Coelho"
subtitle: "Semana de Ciências Sociais"
output:
  beamer_presentation:
    colortheme: dolphin
    fonttheme: structurebold
    theme: CambridgeUS
---

# Introdução

## Objetivos

Nosso objetivo é apresentar a linguagem de programação R para estudantes da graduação em Ciências Sociais da Universidade de São Paulo.

Acreditamos que ao ter um primeiro contato com a programação, o estudante poderá se sentir mais confiante em buscar novos conhecimentos dentro desta ou de outras linguagens.

# O que iremos aprender?

Não trabalharemos aqui com análise de dados ou programação avançada. Iremos englobar assuntos básicos entre eles: [Temos que pensar o tempo da oficina]

- Ambiente do R; 

- Tipos de variáveis;

- Estrutura dos dados;

- Controladores de Fluxos;

- Funções.

# 1. Ambiente do R

- Linguagem de programação.

- Software livre e Comunidade.

## 1.1. O Console

- O R é operado por meio de um **terminal**

![](terminal_r.png)

## 1.2. O RStudio

- Interface Gráfica para o R

- Diferenciais do RStudio pro Terminal do R:

1. Script
2. Ambiênte/Histórico
3. Abinha Multifuncional

***

Interface RStudio: ![](rstudio.png)

# 2. Tipos de Variáveis

O que é uma variável?

Normalmente, quando programamos, nós guardamos os resultados de nossas operações em variáveis. Mas por que eu devo me preocupar com o tipo de variável? Existem dois motivos importantes para isso. 

Em primeiro lugar, cada variável ocupa um determinado espaço da sua memória. A fim de otimizar o seu código, é importante ficar atento para não guardar valores "pequenos" em variávels "grandes". Dificilmente isso será um problema para você a não ser que você esteja utilizando bancos de dados relativamente grandes.

Em segundo lugar, quando você realiza análises mais sofisticadas, como, por exemplo, uma regressão linear, o R é importante estar atento ao tipo de cada variável. Por exemplo, caso você queira que o R trate uma variável como numérica ela não pode ser guardada como se fosse uma variável de texto.

- Double

- Integer

- Boolean

- Character

- Factor



## 2.1. Double

As variáveis double representam os números **reais**. Por padrão, o R guarda qualquer variável númerica com oum *double*.

Existe uma função no R muito útil para saber qual o tipo de uma variável. Ela se chama *typeof*. Para usá-la:

```{r}
typeof(Variável)
```

```{r}
typeof(1) #Qual o tipo da variável 1?
```

## 2.2. Integer

As variáveis de tipo float represetam os números **inteiros**.

## 2.3. Boolean

De maneira geral, eles são consequências de testes de condição. Quando obtemos o 1, dizemos que esse teste foi verdadeiro. Quando obtemos o 0, dizemos que esse teste foi falso. 

As variáveis booleanas são normalmente utilizadas para controles de fluxo e, consequentemente, na automatizaçao de tarefas.

- Variável com dois valores: FALSE (0), TRUE (1)

## 2.3.1. Operações Booleanas

As variáveis boolenas são resultados de equações boolenas. Que equações são essas? Existem duas maneiras de operacionalizar essas equeções. Podemos nos perguntar,(1) se duas afirmações são verdadeiras, ou (2) se pelo menos uma delas é verdadeira. No primeiro caso, temos as operações de tipo **and** ("e"). No segundo caso, temos as operações de tipo **or** ("ou").

1. **And (&)**

Queremos saber se dois testes são verdadeiros. O resultado dessa operação tem a seguinte lógica: necessariamente os dos lados devem ser verdadeiros para que a equaçãos seja verdadeira. Caso contrário, ela é falsa.

Por exemplo, imagine a seguinte frase: "2 é maior que 1 e 3 é maior que 2?". Provavelmente a sua resposta foi sim. Nesse caso, o valor booleano dessa operação é TRUE(1), ou VERDADEIRO(1).

Antes de praticar, vamos fazer mais um exemplo. Agora vou escrever em matematiquês. "2 x 5 == 10 &(e) 3 x 3 > 10". Vamos por partes. Vamos olhar para a parte esquerda primeiro. Quanto é 2 x 5? 10. 10 é igual 10? Sim! Muito bem! A nossa parte esquerda é verdadeira. E a direita? 3 x 3 é 9. 9 é maior que 10? Não. Logo a parte direita da nossa equação é falsa. Como as operações de tipo **and** necessitam que os dois lados sejam verdadeiros, o resultado é que a nossa equação boolena é falsa.

Como já sabemos a lógica, vamos praticar!

```{r}
#Vamos mandar o R fazer essa última equação para gente
#Note que no R, o sinal de multiplicação é o *

2 * 5 == 10 & 3 * 3 > 10 

#Deseja treinar um pouco mais? Faça essas próximas de cabeça e depois peça para o R lhe mostrar o resultado.

1 + 2 < 3 & 2 * 1 > 1

```

Os resultados de uma equação **and** podem ser observados na seguinte tabela.

------|TRUE   |   FALSE|
------|-------|--------|
TRUE  | TRUE  | FALSE  |
FALSE | FALSE | FALSE  |

2. **Or (|)**

Equações de tipo **or** são parecidas com a anterior, mas o resultado delas, digamos assim, é mais "brando". Nessas equações, basta que uma das afirmaçõs seja verdadeira para se obter um resultado verdadeiro.

```{r}
#10 é maior que 2 ou 2 é menor que 4?

10 > 2 | 2 < 4
```

------|TRUE   |   FALSE|
------|-------|--------|
TRUE  | TRUE  | TRUE  |
FALSE | TRUE | FALSE  |

## 2.4. Character

- A variável *string* do R. Ela basicamente é uma variável para guardar textos. Normalmente nós não trabalhos com esse tipo de variável em bancos de dados, mas caso você utilize o R para análises de texto, você trabalhará bastante com ela.

```{r}
typeof("Hello World!")
```

## 2.5. Factor

Por fim, chegamos ao fator. Ele é uma extensão da variável character. Eles são as variáveis categóricas do R. Podemos definí-los como nominais ou ordinais.

```{r}
fator <-  (c("Bom", "Ótimo", "Ruim", "Reguar"))

typeof(fator) 

#Te peguei! Calma. Por padrão, o R guarda essas variáveis como *character*.

#Precisamos falar para o R que essas variáveis são um *factor*.

#Primeiro a gente informa que a nossa variável possui níveis
levels(fator) <- c("Ótimo", "Bom" , "Reguar" , "Ruim")
```

# 3. Estrutura dos Dados

- Vetores

- Lista

- Matrizes

- Data Frame

## 3.1. Vetores

Uma maneira de guardar variáveis de um **mesmo tipo**.

```{r}
vetor <- c(1,2,3,4,5) #Guardei a seguência dentro do "vetor"
```

Caso eu queria fazer referência a um valor específico

```{r}
vetor[1] #Chama o primeiro valor de um vetor.
```

## 3.2. Listas

Semelhante a um vetor, a lista é uma forma de guardar valores de **diferentes tipos**.

```{r}
lista_r <- list("Rafael", 20, 1.87, "São Paulo") #Cria uma lista

lista_r[1]

lista_r[[1]]
```

## 3.3. Matrizes

Enquanto o **vetor** é unidimensional, as matrizes são **bidimensionais**.

```{r}
matriz_1 <- matrix(data = c(1,2,3,4), 
                   nrow = 2, 
                   ncol = 2, 
                   byrow = T) #Cria uma matriz 2x2 com os números 1,2,3,4

matriz_1

```

Caso eu queria chamar uma valor agora preciso fornecer em qual linha e coluna ele está.

```{r}
matriz_1[1,2] #Chama o valor da linha 1 e coluna 2
```

## 3.4. Data Frames

Até agora vimos estruturas de dados muito diferentes do que estamos acostumados. Podemos até nos perguntar, "mas onde eu vou usar um vetor? e as listas?". Por incrível que pareça, eles estão mais próximos do que imaginamos, eles formam o que chamamos de __Data Frames__.

Data Frame é a estrutura de dados mais utilizada no R, principalmente para guardar dados. Podemos pensar que um data frame do R é equivalente a uma planilha do Excel.

Ok, mas como vetores, listas e matrizes fazem parte de um Data Frame?

1. Data frames podem ser representados por um tipo especial de lista em que cada elemento da lista tem o mesmo tamanho

```{r}
filmes <- list(nome = c("Coração Valente", "Tatuagem", "Central do Brasil"), avaliacao = c(2,5,3), classf = c("Aventura", "Drama", "Drama"))

df <- data.frame(filmes)
```
2. Também podemos simplificar, considerando um data frame como um conjunto de vetores de mesmo tamanho.

```{r}
nome <- c("Coração Valente", "Tatuagem", "Central do Brasil")

avaliacao <- c(2,5,3)

classf <- c("Aventura", "Drama", "Drama")

df <- data.frame(nome, avaliacao, classf)
```

Vimos que para criar um Data frame tivemos que usar a função `data.frame()`, mas e se nós quisermos trabalhar com tabelas prontas, isto é, importar dados?

Para isso podemos usar as funções: `read.table()`, `read.csv()` ou `read.csv2()`. Vamos ver um exemplo:

```{r}
criticas <- read.csv2(file = "https://raw.githubusercontent.com/ngiachetta/oficina_R_2017/master/Material/OmeleteDf.csv", header = TRUE, sep = ";", stringsAsFactors = FALSE)

head(criticas) #Retorna as seis primeiras observações da tabela

str(criticas) #Retorna a estrutura dos dados
```

### 3.4.1 Acessando as colunas e observações

Caso nosso objetivo seja olhar para apenas uma coluna podemos utilizar o seguinte símbolo: \$, ele nos retornará todas as observações da coluna.

```{r}
criticas$notacriticaV
```

Outra forma de acessar os dados pode ser realizada da mesma forma que fizemos com as matrizes.

```{r}
criticas[1:10,11]
```

# 4. Controladores de Fluxo

Para essa seção iremos utilizar um banco de dados do Museu de Arte Moderna de Nova York (MoMa), porém, como conseguiremos extrair estes dados? Simples, no [github](https://github.com/) existe um repositório com as [coleções do Museu](https://github.com/MuseumofModernArt/collection). Para extrair estes dados, vamos utilizar a função `read.csv()`.
```{r}
moma <- read.csv ("https://raw.githubusercontent.com/ngiachetta/oficina_R_2017/master/Material/MOMA_Oficina.csv",  header = TRUE, sep = ";", stringsAsFactors = FALSE)
```

## 4.1 condições com o if

Vamos verificar como funciona um _condicional_, ou também chamado de _if_. Podemos pensar da seguinte forma: "Se algo for Verdade, então faça isso". Muitas vezes ele é utilizado com outro comando, o  _else_, que significa: "... Caso negativo, faça isso"

```{r}
if(<condicao>){
  <comando1>
  <comando2>
  <etc>
}else{
  <comando1>
  <comando2>
  <etc>
}
```

Vejamos então o exemplo abaixo:
if: O if a seguir aceita apenas um valor lógico como argumento.

```{r}
if (moma$Nationality[2] == "American") {
  print ("A observação é americana")
} else {
  print ("A observação não é americana")
}

#Par ou ímpar
numero = 12323
if (numero %% 2 ==  0) {
  paste0 (numero, " é par", collapse = " ")
} else {
  paste0 (numero, " é ímpar", collapse = " ")
}
```

Percebam que o comando _if_ realiza a condição apenas para casos não vetorizados. Se, por exemplo, nosso intuito fosse classificar se todas as nossas 100.410 observações fossem americanos ou não, o if não seria a melhor opção, pois ele não consegue percorrer todo vetor. Para isso temos o _ifelse_,que veremos no fim desta seção.

## 4.2 Loops com o for

E se nós quisessemos percorrer os primeiros 10 valores da coluna nacionalida do nosso banco de dados? Uma das soluções para isso é usar o for!

```{r}
for (i in 1:10){
  print(moma$Nationality[i])
}
```

Nós lemos o for da seguinte maneira: Para cada valor "i" presente na sequência "x", realize tais comandos.

```{r}
for (i in x){
  <comando1>
  <comando2>
}
```

Vamos ver mais um exemplo:

```{r}
for (i in 1:10){
  print(moma$Artist[i])
  print(moma$Classification[i])
}
```
É muito importante tomar cuidado com os símbolos que vocês colocam nos valores para realizar os loops. Se colocarmos símbolos em já existentes, o R vai sobreescrever o objeto existente com o que nós criamos.

## 4.3 Loops com o while

O while retorna um comando até que a condição continuar verdadeira.

```{r}
while (<condicao>){
  <comando1>
  <comando2>
}
```

Parecido com os anteriores, não? A principal diferença do while é devido ao fato de que ele continuará executando o comando até que a condição se torne falsa. Vamos ver o seguinte exemplo:

```{r}
l <- 0
while (l <= 20){
  print(moma$DateAcquired[l])
  l = l + 1
}
```

Mas o que aconteceu acima? O comando acima pode ser "traduzido" da seguinte maneira: Enquanto l for menor que 20, execute o comando 1 e o comando 2. Ajudou? Não? 

Nós começamos nosso código atribuindo um valor para um objeto. Esse objeto, quando utilizamos o while, chama-se *iterador*, ele vai permitir que nosso código comece a andar. Perceba que nosso segundo comando adiciona o valor 1 no nosso objeto, isso vai ajudar o nosso iterador chegar até um valor cuja condição se torna falsa. Portanto, começamos com o iterador valendo 0 e terminamos com ele valendo 21.

## 4.4 Podemos usar os controladores de fluxo em conjunto?

Aprender como utilizar os Controladores de fluxo nos ajuda bastante em automatizar tarefas, utilizá-los em conjunto ajuda ainda mais.

Vamos olhar a variável **artist_age**, ela tem a idade dos autores das obras. Algumas observações têm valores negativos, isso significa que eles ainda estão vivos pois a variável foi construída pegando a diferença entre a idade do falecimento e a idade de nascimento. Que tal verificarmos quem está vivo e quem faleceu? Além disso, vamos verificar qual a idade daqueles que estão vivos?

### 4.4.1 while e if

```{r}
m <- 1
while (m <= nrow(moma)){
  if (moma$artist_age[m] < 0){
    moma$vivomorto[m] <- "vivo"
  }else if(moma$artist_age[m] == 0){
    moma$vivomorto[m] <- "sem dados"
  }else{
    moma$vivomorto[m] <- "morto"
  }
  m = m + 1
}

```

### 4.4.2 for e if

```{r}
for (k in 1:nrow(moma)){
  if (moma$artist_age[k] <= 0){
    moma$artist_age[k] <- 2017 - moma$BeginDate[k]
  }
}
```

### 4.4.3 Bônus: Ifelse

Como já vimos, um data.frame é um conjunto de vetores do mesmo tamanho, vetores estes que possuem tipos de dados diferentes, podendo ser double, logical, interger e etc. 

O `ifelse()` para além de conseguir fazer o mesmo que o _if_, ele permite realizar condicionais com objetos vetorizados. Vejamos:

```{r}
#Criando uma variável na tabela do MOMA
moma$ehamericano <- ifelse(moma$Nationality == "American", 
                           yes = "É americano", 
                           no = "Não é americano")

table(moma$ehamericano)

#Par ou Impar
ifelse(200 %% 2 == 0, "Par", "Impar")
```

# 5. Funções

- O que é uma função no R?
