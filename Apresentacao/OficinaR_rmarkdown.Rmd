---
title: "Oficina de R"
author: "Nathan Giachetta & Rafael Coelho"
subtitle: "Semana de Ciências Sociais"
output:
  beamer_presentation:
    colortheme: dolphin
    fonttheme: structurebold
    theme: CambridgeUS
---

# Introdução

## Objetivos

Nosso objetivo é apresentar a linguagem de programação R para estudantes da graduação em Ciências Sociais da Universidade de São Paulo.

Acreditamos que ao ter um primeiro contato com a programação, o estudante poderá se sentir mais confiante em buscar novos conhecimentos dentro desta ou de outras linguagens.

# O que iremos aprender?

Não trabalharemos aqui com análise de dados ou programação avançada. Iremos englobar assuntos básicos entre eles: [Temos que pensar o tempo da oficina]

- Ambiente do R; 

- Tipos de variáveis;

- Estrutura dos dados;

- Controladores de Fluxos;

- Funções.

# 1. Ambiente do R

- Linguagem de programação.

- Software livre e Comunidade.

## 1.1. O Console

- O R é operado por meio de um **terminal**

![](terminal_r.png)

## 1.2. O RStudio

- Interface Gráfica para o R

- Diferenciais do RStudio pro Terminal do R:

1. Script
2. Ambiente/Histórico
3. Abinha Multifuncional

***

Interface RStudio: ![](rstudio.png)

# 2. Tipos de Variáveis

O que é uma variável?

Normalmente, quando programamos, nós guardamos os resultados de nossas operações em variáveis. Mas por que eu devo me preocupar com o tipo de variável? Existem dois motivos importantes para isso. 

Em primeiro lugar, cada variável ocupa um determinado espaço da sua memória. A fim de otimizar o seu código, é importante ficar atento para não guardar valores "pequenos" em variável "grandes". Dificilmente isso será um problema para você a não ser que você esteja utilizando bancos de dados relativamente grandes.

Em segundo lugar, quando você realiza análises mais sofisticadas, como, por exemplo, uma regressão linear, o R é importante estar atento ao tipo de cada variável. Por exemplo, caso você queira que o R trate uma variável como numérica ela não pode ser guardada como se fosse uma variável de texto.

- Double

- Integer

- Boolean

- Character

## 2.1. Double

As variáveis double representam os números **reais**. Por padrão, o R guarda qualquer variável numérica como um *double*.

Existe uma função no R muito útil para saber qual o tipo de uma variável. Ela se chama *typeof*. Para usá-la:

```{r}
typeof(Variável)
```

```{r}
typeof(1) #Qual o tipo da variável 1?
```

## 2.2. Integer

As variáveis de tipo float representam os números **inteiros**.

## 2.3. Boolean

De maneira geral, eles são consequências de testes de condição. Quando obtemos o 1, dizemos que esse teste foi verdadeiro. Quando obtemos o 0, dizemos que esse teste foi falso. 

As variáveis booleanas são normalmente utilizadas para controles de fluxo e, consequentemente, na automatização de tarefas.

- Variável com dois valores: FALSE (0), TRUE (1)

## 2.3.1. Operações Booleanas

As variáveis booleanas são resultados de equações booleanas. Que equações são essas? Existem duas maneiras de operacionalizar essas equações. Podemos nos perguntar,(1) se duas afirmações são verdadeiras, ou (2) se pelo menos uma delas é verdadeira. No primeiro caso, temos as operações de tipo **and** ("e"). No segundo caso, temos as operações de tipo **or** ("ou").

1. **And (&)**

Queremos saber se dois testes são verdadeiros. O resultado dessa operação tem a seguinte lógica: necessariamente os dos lados devem ser verdadeiros para que a equações seja verdadeira. Caso contrário, ela é falsa.

Por exemplo, imagine a seguinte frase: "2 é maior que 1 e 3 é maior que 2?". Provavelmente a sua resposta foi sim. Nesse caso, o valor booleano dessa operação é TRUE(1), ou VERDADEIRO(1).

Antes de praticar, vamos fazer mais um exemplo. Agora vou escrever em matematiquês. "2 x 5 == 10 &(e) 3 x 3 > 10". Vamos por partes. Vamos olhar para a parte esquerda primeiro. Quanto é 2 x 5? 10. 10 é igual 10? Sim! Muito bem! A nossa parte esquerda é verdadeira. E a direita? 3 x 3 é 9. 9 é maior que 10? Não. Logo a parte direita da nossa equação é falsa. Como as operações de tipo **and** necessitam que os dois lados sejam verdadeiros, o resultado é que a nossa equação booleana é falsa.

Como já sabemos a lógica, vamos praticar!

```{r}
#Vamos mandar o R fazer essa última equação para gente
#Note que no R, o sinal de multiplicação é o *

2 * 5 == 10 & 3 * 3 > 10 

#Deseja treinar um pouco mais? Faça essas próximas de cabeça e depois peça para o R lhe mostrar o resultado.

1 + 2 < 3 & 2 * 1 > 1

```

Os resultados de uma equação **and** podem ser observados na seguinte tabela.

------|TRUE   |   FALSE|
------|-------|--------|
TRUE  | TRUE  | FALSE  |
FALSE | FALSE | FALSE  |

2. **Or (|)**

Equações de tipo **or** são parecidas com a anterior, mas o resultado delas, digamos assim, é mais "brando". Nessas equações, basta que uma das afirmações seja verdadeira para se obter um resultado verdadeiro.

```{r}
#10 é maior que 2 ou 2 é menor que 4?

10 > 2 | 2 < 4
```

------|TRUE   |   FALSE|
------|-------|--------|
TRUE  | TRUE  | TRUE  |
FALSE | TRUE | FALSE  |

## 2.4. Character

- A variável *string* do R. Ela basicamente é uma variável para guardar textos. Normalmente nós não trabalhos com esse tipo de variável em bancos de dados, mas caso você utilize o R para análises de texto, você trabalhará bastante com ela.

```{r}
typeof("Hello World!")
```

# 3. Estrutura dos Dados

Até agora trabalhos como tipos de variáveis atômicos. Além de guardar resultados isolados em variáveis, nós podemos guardar conjuntos de variáveis. Quando fazemos isso, nós deixamos de trabalhar apenas com variáveis e passamos a trabalhar também com estruturas de dados.

No R, nós temos 4 principais estruturas de dados:

- Vetores

- Lista

- Matrizes

- Data Frame

## 3.1. Vetores

Quando utilizamos vetores, nós guardamos valores em uma determinado ordem. Por exemplo, eu posso guardar o a sequência 1, 2, 3, 4 e 5 dentro de um vetor chamado "sequência". Nesse caso, o nosso vetor é composto de variáveis "double".

Em tese, podemos criar vetores com quaisquer tipos de variáveis. Contudo, essa estrutura de dados pode apenas conter valores de um mesmo tipo. Por exemplo, caso eu guarde em um vetor a seguinte sequência **1, 2, "Oi", 4.2, TRUE**, o R converto todos os valores para o mínimo comum entre eles. No caso, todos seriam tratados como *character*

```{r}
#Para criar vetores no R, utilizamos o comando "c()"

#Criando um vetor de 1 a 5 e guardando sob o nome "sequência"
sequencia <- c(1,2,3,4,5) 


```

Como o conjunto de dados possui uma ordem, podemos chamar cada um dos valores utilizando os colchetes "[]".

```{r}
#Para chamar o valor da posição "i" de um vetor, utilizamos a seguinte estrutura

vetor[i]

#Podemos substituir o "i" pela posição do valor de interesse e o "vetor" pelo nome que demos ao nosso vetor.

sequencia[1]
```

## 3.1.1. Factor

Nós podemos falar para o R que os valores dentro dessa estrutura de dados possuem "níveis". 

Com isso, podemos trabalhar com dados categóricos no R. 

```{r}
fator <-  c("Bom", "Ótimo", "Ruim", "Reguar")

typeof(fator) 

#Precisamos falar para o R que essas variáveis são um *factor*.

#Primeiro a gente informa que a nossa variável possui níveis

levels(fator) <- c("Ótimo", "Bom" , "Reguar" , "Ruim")
```

Lembre-se que os valores contidos dentro de um vetor continuam sendo considerados *character*. Caso você use a função "typeof()".

## 3.2. Listas

Vamos dizer que você queira guardar informações sobre um dos organizadores dessa disciplina. Uma das maneiras de se fazer isso é pelo uso de uma lista. Com ela, pomos guardar valores de diferentes tipos. Ao contrário do vetor, em que os dados precisam ser de mesmo tipo, com a lista não temos essa limitação.

Por exemplo, um dos organizados se chama Rafael. Ele tem 20 anos, 1,87 metros de altura e mora em São Paulo.

```{r}
#Uma lista com as informações de Rafael
lista_r <- list(nome = "Rafael",
                idade = 20,
                altura = 1.87,
                mora = "São Paulo") 
```

Como você viu, outra vantagem da lista é que podemos dar "nomes" às variáveis. Logo nós podemos chamar uma valor dela não só pela posição, mas também a partir desse "nome". Para isso, utilizamos o "$".

Por exemplo, caso eu queira, o valores de uma lista guardados em "idade", podemos utilizar lista_r$idade. Contudo, nós também podemos chamar um valor de acordo com a posição que ele ocupa. A única diferença é que agora nós devemos utilizar dois colchetes ao invés de um "[[]]".

```{r}
#Para chamar um valor dentro da lista, ou chamamos pelo "nome" de sua posição, ou pela posição "i" que ele ocupa
lista$nome

lista[[i]]

#Na nossa lista, podemos chamar idade de duas maneiras.

#Ou utilizamos

lista_r$idade

#Ou, como idade ocupa a segunda posição da lista, utilizamos

lista_r[[2]]
```

## 3.3. Matrizes

Aprendemos a guardar valores em vetores e listas. Caso você já tenha trabalhado com banco de dados, deve saber que dificilmente nós nos detemos a um único caso. De maneira geral, nossos bancos de dados tem formato retangular, com diversas observações e variáveis.

Antes de apresentar a maneira mais comum de trabalhar com bancos de dados no R, vamos trabalhar rapidamente com a ideia de matrizes. Ao contrário de vetores que se limitam a uma representação **unidimensional** dos dados, com as matrizes, podemos guardar informações de maneira **bidimensional**.

Porém, assim, como os vatores, matrizes necessariamente guardam valores de mesmo tipo.

Vamos ver um pouquinho disso na prática.

```{r}
#Cria uma matriz 2x2 com os números 1,2,3,4
matriz_1 <- matrix(data = c(1,2,3,4), 
                   nrow = 2, 
                   ncol = 2, 
                   byrow = T) 

matriz_1
```

Com uma matriz, não basta informar a posição "i" do nosso dado. Precisamos dar a linha e a coluna que queremos. Por exemplo, caso você queira o valor contido na linha 1, coluna 2, escrevemos a seguinte expressão:

```{r}
matriz_1[1,2] 
```

A partir disso, já podemos pensar em uma regra geral para chamar dados de matrizes.

```{r}
#Para chamar o valor contido em uma linha "i" e uma coluna "j" de uma "matriz", utilizamos a seguinte expressão:
matriz[i,j]
```

## 3.4. Data Frames

Até agora vimos estruturas de dados muito diferentes do que estamos acostumados. Podemos até nos perguntar, "mas onde eu vou usar um vetor? e as listas?". Por incrível que pareça, eles estão mais próximos do que imaginamos, eles formam o que chamamos de __Data Frames__.

Data Frame é a estrutura de dados mais utilizada no R, principalmente para guardar dados. Podemos pensar que um data frame do R é equivalente a uma planilha do Excel.

Ok, mas como vetores, listas e matrizes fazem parte de um Data Frame?

1. Data frames podem ser representados por um tipo especial de lista em que cada elemento da lista tem o mesmo tamanho

```{r}
filmes <- list(nome = c("Coração Valente", "Tatuagem", "Central do Brasil"), avaliacao = c(2,5,3), classf = c("Aventura", "Drama", "Drama"))

df <- data.frame(filmes)
```
2. Também podemos simplificar, considerando um data frame como um conjunto de vetores de mesmo tamanho.

```{r}
nome <- c("Coração Valente", "Tatuagem", "Central do Brasil")

avaliacao <- c(2,5,3)

classf <- c("Aventura", "Drama", "Drama")

df <- data.frame(nome, avaliacao, classf)
```

Vimos que para criar um Data frame tivemos que usar a função `data.frame()`, mas e se nós quisermos trabalhar com tabelas prontas, isto é, importar dados?

Para isso podemos usar as funções: `read.table()`, `read.csv()` ou `read.csv2()`. Vamos ver um exemplo:

```{r}
criticas <- read.csv2(file = "https://raw.githubusercontent.com/ngiachetta/oficina_R_2017/master/Material/OmeleteDf.csv", header = TRUE, sep = ";", stringsAsFactors = FALSE)

head(criticas) #Retorna as seis primeiras observações da tabela

str(criticas) #Retorna a estrutura dos dados
```

### 3.4.1 Acessando as colunas e observações

Caso nosso objetivo seja olhar para apenas uma coluna podemos utilizar o seguinte símbolo: \$, ele nos retornará todas as observações da coluna.

```{r}
criticas$notacriticaV
```

Outra forma de acessar os dados pode ser realizada da mesma forma que fizemos com as matrizes.

```{r}
criticas[1:10,11]
```

# 4. Controladores de Fluxo

Para essa seção iremos utilizar um banco de dados do Museu de Arte Moderna de Nova York (MoMa), porém, como conseguiremos extrair estes dados? Simples, no [github](https://github.com/) existe um repositório com as [coleções do Museu](https://github.com/MuseumofModernArt/collection). Para extrair estes dados, vamos utilizar a função `read.csv()`.
```{r}
moma <- read.csv ("https://raw.githubusercontent.com/ngiachetta/oficina_R_2017/master/Material/MOMA_Oficina.csv",  header = TRUE, sep = ";", stringsAsFactors = FALSE)
```

## 4.1 condições com o if

Vamos verificar como funciona um _condicional_, ou também chamado de _if_. Podemos pensar da seguinte forma: "Se algo for Verdade, então faça isso". Muitas vezes ele é utilizado com outro comando, o  _else_, que significa: "... Caso negativo, faça isso"

```{r}
if(<condicao>){
  <comando1>
  <comando2>
  <etc>
}else{
  <comando1>
  <comando2>
  <etc>
}
```

Vejamos então o exemplo abaixo:
if: O if a seguir aceita apenas um valor lógico como argumento.

```{r}
if (moma$Nationality[2] == "American") {
  print ("A observação é americana")
} else {
  print ("A observação não é americana")
}

#Par ou ímpar
numero = 12323
if (numero %% 2 ==  0) {
  paste0 (numero, " é par", collapse = " ")
} else {
  paste0 (numero, " é ímpar", collapse = " ")
}
```

Percebam que o comando _if_ realiza a condição apenas para casos não vetorizados. Se, por exemplo, nosso intuito fosse classificar se todas as nossas 100.410 observações fossem americanos ou não, o if não seria a melhor opção, pois ele não consegue percorrer todo vetor. Para isso temos o _ifelse_,que veremos no fim desta seção.

## 4.2 Loops com o for

E se nós quiséssemos percorrer os primeiros 10 valores da coluna nacionalida do nosso banco de dados? Uma das soluções para isso é usar o for!

```{r}
for (i in 1:10){
  print(moma$Nationality[i])
}
```

Nós lemos o for da seguinte maneira: Para cada valor "i" presente na sequência "x", realize tais comandos.

```{r}
for (i in x){
  <comando1>
  <comando2>
}
```

Vamos ver mais um exemplo:

```{r}
for (i in 1:10){
  print(moma$Artist[i])
  print(moma$Classification[i])
}
```
É muito importante tomar cuidado com os símbolos que vocês colocam nos valores para realizar os loops. Se colocarmos símbolos em já existentes, o R vai sobreescrever o objeto existente com o que nós criamos.

## 4.3 Loops com o while

O while retorna um comando até que a condição continuar verdadeira.

```{r}
while (<condicao>){
  <comando1>
  <comando2>
}
```

Parecido com os anteriores, não? A principal diferença do while é devido ao fato de que ele continuará executando o comando até que a condição se torne falsa. Vamos ver o seguinte exemplo:

```{r}
l <- 0
while (l <= 20){
  print(moma$DateAcquired[l])
  l = l + 1
}
```

Mas o que aconteceu acima? O comando acima pode ser "traduzido" da seguinte maneira: Enquanto l for menor que 20, execute o comando 1 e o comando 2. Ajudou? Não? 

Nós começamos nosso código atribuindo um valor para um objeto. Esse objeto, quando utilizamos o while, chama-se *iterador*, ele vai permitir que nosso código comece a andar. Perceba que nosso segundo comando adiciona o valor 1 no nosso objeto, isso vai ajudar o nosso iterador chegar até um valor cuja condição se torna falsa. Portanto, começamos com o iterador valendo 0 e terminamos com ele valendo 21.

## 4.4 Podemos usar os controladores de fluxo em conjunto?

Aprender como utilizar os Controladores de fluxo nos ajuda bastante em automatizar tarefas, utilizá-los em conjunto ajuda ainda mais.

Vamos olhar a variável **artist_age**, ela tem a idade dos autores das obras. Algumas observações têm valores negativos, isso significa que eles ainda estão vivos pois a variável foi construída pegando a diferença entre a idade do falecimento e a idade de nascimento. Que tal verificarmos quem está vivo e quem faleceu? Além disso, vamos verificar qual a idade daqueles que estão vivos?

### 4.4.1 while e if

```{r}
m <- 1
while (m <= nrow(moma)){
  if (moma$artist_age[m] < 0){
    moma$vivomorto[m] <- "vivo"
  }else if(moma$artist_age[m] == 0){
    moma$vivomorto[m] <- "sem dados"
  }else{
    moma$vivomorto[m] <- "morto"
  }
  m = m + 1
}

```

### 4.4.2 for e if

```{r}
for (k in 1:nrow(moma)){
  if (moma$artist_age[k] <= 0){
    moma$artist_age[k] <- 2017 - moma$BeginDate[k]
  }
}
```

### 4.4.3 Bônus: Ifelse

Como já vimos, um data.frame é um conjunto de vetores do mesmo tamanho, vetores estes que possuem tipos de dados diferentes, podendo ser double, logical, interger e etc. 

O `ifelse()` para além de conseguir fazer o mesmo que o _if_, ele permite realizar condicionais com objetos vetorizados. Vejamos:

```{r}
#Criando uma variável na tabela do MOMA
moma$ehamericano <- ifelse(moma$Nationality == "American", 
                           yes = "É americano", 
                           no = "Não é americano")

table(moma$ehamericano)

#Par ou Impar
ifelse(200 %% 2 == 0, "Par", "Impar")
```

# 5. Funções

- O que é uma função no R?
